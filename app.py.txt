# ============================================================
# TimeSculpt ‚Äî Phase 6.3 (Final Production Build, single-file)
# ============================================================

import streamlit as st
import sqlite3, bcrypt, random, os, json
import plotly.express as px
from datetime import datetime, timedelta, time as dtime
from openai import OpenAI

# ---------------------
# App Config & Styling
# ---------------------
st.set_page_config(page_title="TimeSculpt", layout="wide")
st.markdown("""
<style>
:root {
  --bg: #0b0f19;
  --card: #111729;
  --fg: #e7eaf3;
  --muted: #a7b0c0;
  --gold: #f6c453;
  --accent: #7aa2ff;
}
html, body, .stApp { background: radial-gradient(800px 600px at 90% 10%, #0f1630 0%, var(--bg) 60%); color: var(--fg); }
h1, h2, h3, h4, h5 { color: var(--fg); }
.stTabs [role="tab"] { font-weight: 700; color: var(--fg) !important; }
.stTabs [role="tab"][aria-selected="true"] { border-bottom: 3px solid var(--gold) !important; }
textarea, input, select, .stTextInput>div>div>input, .stTextArea textarea, .stDateInput input, .stTimeInput input {
  background: var(--card) !important; color: var(--fg) !important; border-radius: 10px !important;
}
.css-1dp5vir, .stSlider, .stCheckbox, .stSelectbox { color: var(--fg) !important; }
.block-container { padding-top: 1.2rem; }
.card { background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01)); border: 1px solid rgba(255,255,255,0.05); border-radius: 14px; padding: 14px 16px; margin: 8px 0; }
.narr { border-left: 4px solid var(--gold); background: rgba(246,196,83,0.08); padding: 12px 14px; border-radius: 8px; color:#ffe9b7; font-style: italic;}
.metric .stMetricValue { color: var(--gold) !important; font-weight: 800 !important; }
.small { color: var(--muted); font-size: 0.9rem; }
</style>
""", unsafe_allow_html=True)

# -------------
# DB Utilities
# -------------
DB = "timesculpt.db"

def _exec(conn, q, params=()):
    cur = conn.cursor()
    cur.execute(q, params)
    return cur

def init_db():
    with sqlite3.connect(DB) as conn:
        _exec(conn, """CREATE TABLE IF NOT EXISTS profiles(
            id INTEGER PRIMARY KEY, name TEXT UNIQUE, pin_hash TEXT,
            api_key TEXT, ai_enabled INT DEFAULT 0, ai_model TEXT DEFAULT 'gpt-4o-mini',
            demo INT DEFAULT 0, thresholds TEXT DEFAULT '{}'
        )""")
        _exec(conn, """CREATE TABLE IF NOT EXISTS goals(
            id INTEGER PRIMARY KEY, profile_id INT, name TEXT, target REAL,
            unit TEXT, deadline TEXT, priority INT
        )""")
        _exec(conn, """CREATE TABLE IF NOT EXISTS loops(
            id INTEGER PRIMARY KEY, profile_id INT, category TEXT,
            value REAL, date TEXT, time TEXT
        )""")
        _exec(conn, """CREATE TABLE IF NOT EXISTS future_self(
            id INTEGER PRIMARY KEY, profile_id INT, title TEXT,
            traits TEXT, rituals TEXT, letter TEXT
        )""")
        _exec(conn, """CREATE TABLE IF NOT EXISTS interventions(
            id INTEGER PRIMARY KEY, profile_id INT, description TEXT,
            status TEXT, completed_date TEXT, helpful TEXT, reflection TEXT
        )""")
        _exec(conn, """CREATE TABLE IF NOT EXISTS lens(
            id INTEGER PRIMARY KEY, profile_id INT, passage TEXT,
            category TEXT, active INT DEFAULT 1
        )""")
        conn.commit()

def column_exists(table, column):
    with sqlite3.connect(DB) as conn:
        cols = [r[1] for r in _exec(conn, f"PRAGMA table_info({table})").fetchall()]
        return column in cols

def add_column_if_missing(table, column, coltype, default=None):
    if not column_exists(table, column):
        with sqlite3.connect(DB) as conn:
            _exec(conn, f"ALTER TABLE {table} ADD COLUMN {column} {coltype}")
            if default is not None:
                _exec(conn, f"UPDATE {table} SET {column}=?", (default,))
            conn.commit()

def migrate_db():
    init_db()
    # Loops: ensure time column
    add_column_if_missing("loops", "time", "TEXT", "08:00:00")
    # Profiles: ai_enabled, ai_model, demo, thresholds, api_key
    add_column_if_missing("profiles", "api_key", "TEXT", "")
    add_column_if_missing("profiles", "ai_enabled", "INT", 0)
    add_column_if_missing("profiles", "ai_model", "TEXT", "gpt-4o-mini")
    add_column_if_missing("profiles", "demo", "INT", 0)
    add_column_if_missing("profiles", "thresholds", "TEXT", "{}")
    # Interventions: helpful/reflection
    add_column_if_missing("interventions", "helpful", "TEXT", "")
    add_column_if_missing("interventions", "reflection", "TEXT", "")
    # Lens: active
    add_column_if_missing("lens", "active", "INT", 1)

def save(q, params=()):
    with sqlite3.connect(DB) as conn:
        _exec(conn, q, params)
        conn.commit()

def fetch(q, params=()):
    with sqlite3.connect(DB) as conn:
        return _exec(conn, q, params).fetchall()

migrate_db()

# -----------------
# Session Helpers
# -----------------
if "profile" not in st.session_state:
    st.session_state.profile = None
if "active_lens_cats" not in st.session_state:
    st.session_state.active_lens_cats = ["recursion", "emergence"]

def current_profile():
    return st.session_state.profile

# -----------------
# AI Integration
# -----------------
def get_ai_client(pid):
    row = fetch("SELECT api_key, ai_enabled, ai_model FROM profiles WHERE id=?", (pid,))
    if not row: return None, None
    api_key, enabled, model = row[0]
    if not enabled or not api_key: return None, model
    try:
        cli = OpenAI(api_key=api_key)
        return cli, model
    except Exception:
        return None, model

def ai_narration(pid, prompt):
    client, model = get_ai_client(pid)
    if not client: return None
    try:
        resp = client.chat.completions.create(
            model=model or "gpt-4o-mini",
            messages=[{"role":"system","content":"You are a concise, motivating coach."},
                      {"role":"user","content":prompt}]
        )
        return resp.choices[0].message.content
    except Exception as e:
        return f"(AI error: {e})"

def blended_lens_line(pid, cats=None):
    if not cats: cats = st.session_state.active_lens_cats or ["recursion","emergence"]
    qmarks = ",".join("?"*len(cats))
    rows = fetch(f"SELECT passage FROM lens WHERE profile_id=? AND active=1 AND category IN ({qmarks})",
                 (pid, *cats))
    if not rows: return None
    return random.choice(rows)[0]

# --------------
# Demo Seeding
# --------------
def seed_demo(pid, days=30):
    today = datetime.now().date()
    cats_force = ["write", "exercise", "study", "meditate", "walk"]
    cats_drag  = ["scroll", "late", "junk", "skip"]
    for i in range(days):
        day = today - timedelta(days=i)
        # push 2-4 loops a day
        for _ in range(random.randint(2,4)):
            cat = random.choice(cats_force + cats_drag)
            val = random.randint(1,3)
            t = dtime(hour=random.choice([6,8,12,18,21]), minute=random.choice([0,15,30,45]))
            save("INSERT INTO loops(profile_id,category,value,date,time) VALUES(?,?,?,?,?)",
                 (pid, f"[DEMO] {cat}", val, day.isoformat(), t.strftime("%H:%M:%S")))
    # One goal
    deadline = (datetime.now() + timedelta(days=30)).date().isoformat()
    save("""INSERT INTO goals(profile_id,name,target,unit,deadline,priority)
            VALUES(?,?,?,?,?,?)""",
         (pid,"[DEMO] Write 30 sessions",30,"sessions", deadline, 4))
    # Interventions
    for text in ("[DEMO] 7-minute writing starter", "[DEMO] 15-minute walk after lunch",
                 "[DEMO] Pay-yourself-first 10%"):
        save("INSERT INTO interventions(profile_id,description,status) VALUES(?,?,?)",
             (pid,text,"pending"))
    # Future self
    save("""INSERT INTO future_self(profile_id,title,traits,rituals,letter) VALUES(?,?,?,?,?)""",
         (pid, "[DEMO] The Disciplined Architect",
          "Systems over moods; Consistency over intensity",
          "Morning walk; Evening shutdown",
          "Dear me, stay consistent. Each small step bends probability toward a better outcome."))
    # Lens
    for p,c in [
        ("Strength lives in small consistencies.","recursion"),
        ("Guard your mornings, guard your attention.","emergence"),
        ("When alignment dips, return to the smallest next move.","neutral")
    ]:
        save("INSERT INTO lens(profile_id,passage,category,active) VALUES(?,?,?,1)", (pid, f"[DEMO] {p}", c))

# --------------
# UI Sections
# --------------
def guide_tab():
    st.header("üìñ TimeSculpt ‚Äî Quick Start & Deep Guide")
    st.markdown("""
**What it is.** TimeSculpt is a multi-goal, identity-first system that converts small daily loops into progress forecasts, interventions that actually help, and narrative guidance in your voice (via Lens or AI).

### Daily Flow
1. **Log Loops** üîÅ ‚Äî Capture writing/exercise/any action with date/time.  
2. **Forecast** üìà ‚Äî See if the week aligns to each goal. Semi-automatic narrative explains why.  
3. **Accept Interventions** üõ† ‚Äî Choose 1 small move. Complete it, then record if it helped.  
4. **Letters Resurface** ‚úâÔ∏è ‚Äî If alignment dips, your Future Self nudges you.

### Weekly Flow
- Review **Diagnostics** ‚öñÔ∏è ‚Äî ratio of Forces vs Drags and the balance index.  
- Reset goals üéØ ‚Äî adjust targets/priority.  
- Refresh Lens üìö ‚Äî add passages; keep narration alive.

### Tabs Overview
- **üë§ Profiles**: create/select/delete; AI toggle, API key, model; demo on/off.  
- **üå† Future Self**: title, traits, rituals, letter (resurfaces when forecast dips).  
- **üéØ Goals**: target/unit/deadline/priority; loop tags to map which loops count.  
- **üîÅ Loops**: category (tag) + value + date + time.  
- **üìà Forecast**: gauges + ribbons + narration (AI or Lens).  
- **üõ† Interventions**: accept ‚Üí complete ‚Üí reflect & mark helpful.  
- **‚öñÔ∏è Diagnostics**: forces vs drags, ratio, narration.

> You are not tracking ‚Äî you are sculpting.
""")

def profiles_tab():
    st.header("üë§ Profiles")
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("Create")
        name = st.text_input("Profile Name")
        pin  = st.text_input("PIN (4+ digits)", type="password")
        if st.button("Create Profile"):
            if not name or not pin:
                st.error("Name and PIN required.")
            else:
                hashed = bcrypt.hashpw(pin.encode(), bcrypt.gensalt()).decode()
                try:
                    save("INSERT INTO profiles(name,pin_hash) VALUES(?,?)",(name,hashed))
                    st.success("Profile created. Select it on the right to login.")
                except sqlite3.IntegrityError:
                    st.error("That profile name already exists.")
    with col2:
        st.subheader("Login / AI / Demo")
        profs = fetch("SELECT id, name FROM profiles ORDER BY name")
        if profs:
            names = [p[1] for p in profs]
            sel_name = st.selectbox("Select Profile", names)
            pin_try = st.text_input("PIN to login", type="password")
            if st.button("Login"):
                row = fetch("SELECT id, pin_hash FROM profiles WHERE name=?", (sel_name,))
                if row and bcrypt.checkpw(pin_try.encode(), row[0][1].encode()):
                    st.session_state.profile = row[0][0]
                    st.success(f"Logged in as {sel_name}")
                else:
                    st.error("Invalid PIN.")
            pid = current_profile()
            if pid:
                row = fetch("SELECT ai_enabled, api_key, ai_model, demo FROM profiles WHERE id=?", (pid,))
                ai_on, api_key, ai_model, demo_on = row[0]
                ai_on_new = st.toggle("Enable AI", bool(ai_on))
                api_key_new = st.text_input("OpenAI API Key", value=api_key or "", type="password")
                model_new = st.selectbox("AI Model", ["gpt-4o-mini","gpt-4o","gpt-3.5-turbo"], index=["gpt-4o-mini","gpt-4o","gpt-3.5-turbo"].index(ai_model or "gpt-4o-mini"))
                demo_new = st.toggle("Enable Demo Data (30 days)", bool(demo_on))
                if st.button("Save Profile Settings"):
                    save("UPDATE profiles SET ai_enabled=?, api_key=?, ai_model=?, demo=? WHERE id=?",
                         (1 if ai_on_new else 0, api_key_new, model_new, 1 if demo_new else 0, pid))
                    if demo_new:
                        seed_demo(pid)
                    st.success("Saved.")
                if st.button("Delete Demo Data"):
                    save("DELETE FROM loops WHERE profile_id=? AND category LIKE '[DEMO]%%'", (pid,))
                    save("DELETE FROM goals WHERE profile_id=? AND name LIKE '[DEMO]%%'", (pid,))
                    save("DELETE FROM interventions WHERE profile_id=? AND description LIKE '[DEMO]%%'", (pid,))
                    save("DELETE FROM lens WHERE profile_id=? AND passage LIKE '[DEMO]%%'", (pid,))
                    save("DELETE FROM future_self WHERE profile_id=? AND title LIKE '[DEMO]%%'", (pid,))
                    st.success("Demo data removed.")

def future_tab():
    st.header("üå† Future Self")
    pid = current_profile()
    if not pid: st.info("Select a profile."); return
    title  = st.text_input("Identity Title (e.g., The Disciplined Architect)")
    traits = st.text_area("Traits (one per line)")
    rituals= st.text_area("Rituals (one per line)")
    letter = st.text_area("Letter to Present Self (used when alignment dips)")
    if st.button("Save Future Self"):
        save("""INSERT INTO future_self(profile_id,title,traits,rituals,letter) VALUES(?,?,?,?,?)""",
             (pid,title,traits,rituals,letter))
        st.success("Saved.")

    rows = fetch("SELECT title, traits, rituals, letter FROM future_self WHERE profile_id=? ORDER BY id DESC LIMIT 3", (pid,))
    if rows:
        st.subheader("Recent Entries")
        for t,tr,ri,le in rows:
            with st.expander(t or "Entry"):
                st.write("**Traits**"); st.code(tr or "")
                st.write("**Rituals**"); st.code(ri or "")
                st.write("**Letter**"); st.write(le or "")

def goals_tab():
    st.header("üéØ Goals")
    pid = current_profile()
    if not pid: st.info("Select a profile."); return
    name = st.text_input("Goal Name")
    target = st.number_input("Target", min_value=0.0, step=1.0)
    unit = st.text_input("Unit (sessions, pages, km, etc.)")
    deadline = st.date_input("Deadline").isoformat()
    priority = st.slider("Priority", 1, 5, 3)
    if st.button("Save Goal"):
        save("""INSERT INTO goals(profile_id,name,target,unit,deadline,priority) VALUES(?,?,?,?,?,?)""",
             (pid,name,target,unit,deadline,priority))
        st.success("Goal saved.")
    rows = fetch("SELECT id,name,target,unit,deadline,priority FROM goals WHERE profile_id=? ORDER BY deadline", (pid,))
    if rows:
        st.subheader("Your Goals")
        for gid, n, t, u, dl, pr in rows:
            st.write(f"‚Ä¢ **{n}** ‚Äî target {t} {u} by {dl} (priority {pr})")

def loops_tab():
    st.header("üîÅ Loops")
    pid = current_profile()
    if not pid: st.info("Select a profile."); return
    category = st.text_input("Category / Tag (e.g., write, exercise, scroll)")
    value    = st.number_input("Value", min_value=0.0, step=1.0)
    date     = st.date_input("Date").isoformat()
    t        = st.time_input("Time", value=dtime(8,0)).strftime("%H:%M:%S")
    if st.button("Log Loop"):
        save("INSERT INTO loops(profile_id,category,value,date,time) VALUES(?,?,?,?,?)",
             (pid, category, value, date, t))
        st.success("Loop saved.")
    rows = fetch("SELECT category, value, date, time FROM loops WHERE profile_id=? ORDER BY date DESC, time DESC LIMIT 20", (pid,))
    if rows:
        st.subheader("Recent")
        for c,v,d,t in rows:
            st.write(f"‚Ä¢ {d} {t} ‚Äî **{c}** (+{v})")

def forecast_tab():
    st.header("üìà Forecast")
    pid = current_profile()
    if not pid: st.info("Select a profile."); return
    goals = fetch("SELECT id,name,target,unit,deadline FROM goals WHERE profile_id=?", (pid,))
    if not goals: st.info("Add a goal first."); return
    # last 30 days loops
    since = (datetime.now().date() - timedelta(days=30)).isoformat()
    total_loops = dict(fetch("SELECT category, SUM(value) FROM loops WHERE profile_id=? AND date>=? GROUP BY category", (pid, since)))
    overall = sum(total_loops.values()) or 0

    for gid, name, target, unit, deadline in goals:
        progress = min(1.0, (overall / max(1.0, target))) if target else 0.0
        # Simple 14-day trend simulation
        x = list(range(14))
        y = [max(0, min(1, progress + random.uniform(-0.05, 0.05))) for _ in x]
        fig = px.line(x=x, y=y, labels={'x':'Days','y':'Success Probability'}, title=name)
        st.plotly_chart(fig, use_container_width=True)
        st.metric(f"{name} Progress toward {target} {unit}", f"{progress*100:.1f}%")
        # Narration
        letter = fetch("""SELECT letter FROM future_self WHERE profile_id=? ORDER BY id DESC LIMIT 1""",(pid,))
        base = f"Goal: {name}. 30-day effort sum={overall:.0f}/{target} {unit}. Probability‚âà{int(progress*100)}%."
        if letter:
            base += " If alignment dips, echo: " + (letter[0][0][:120] + ("‚Ä¶" if len(letter[0][0])>120 else ""))
        narr = ai_narration(pid, base)
        if not narr:
            blend = blended_lens_line(pid, None)
            if blend: narr = blend
        if narr:
            st.markdown(f"<div class='narr'>{narr}</div>", unsafe_allow_html=True)

def interventions_tab():
    st.header("üõ† Interventions")
    pid = current_profile()
    if not pid: st.info("Select a profile."); return
    desc = st.text_input("Intervention Description")
    if st.button("Offer / Add"):
        if desc:
            save("INSERT INTO interventions(profile_id,description,status) VALUES(?,?,?)",(pid,desc,"accepted"))
            st.success("Intervention added.")
    # List
    rows = fetch("""SELECT id, description, status, completed_date, helpful, reflection
                    FROM interventions WHERE profile_id=? ORDER BY id DESC""",(pid,))
    if not rows:
        st.info("No interventions yet."); return
    for iid, d, status, cdate, helpful, refl in rows:
        st.write(f"**{d}** ‚Äî {status if status else 'pending'}")
        # complete button
        cols = st.columns([1,1,3])
        with cols[0]:
            if status != "completed":
                if st.button("Complete", key=f"complete_{iid}"):
                    save("UPDATE interventions SET status=?, completed_date=? WHERE id=?",
                         ("completed", datetime.now().isoformat(), iid))
                    st.rerun()
        with cols[1]:
            if status == "completed":
                helpful_sel = st.selectbox("Helpful?", ["Yes","No"], index=0 if (helpful or "Yes")== "Yes" else 1, key=f"h{iid}")
        with cols[2]:
            if status == "completed":
                refl_txt = st.text_input("Reflection", value=refl or "", key=f"r{iid}")
                if st.button("Save Feedback", key=f"save_{iid}"):
                    save("UPDATE interventions SET helpful=?, reflection=? WHERE id=?",
                         (helpful_sel, refl_txt, iid))
                    st.success("Saved.")
    # Narrative suggestion
    hint = blended_lens_line(pid, ["recursion","neutral"]) or "Return to the smallest next move you can keep."
    st.markdown(f"<div class='small'>Hint: {hint}</div>", unsafe_allow_html=True)

def lens_tab():
    st.header("üìö Lens")
    pid = current_profile()
    if not pid: st.info("Select a profile."); return
    psg = st.text_area("Add Passage")
    cat = st.selectbox("Category", ["recursion","emergence","neutral"])
    active = st.checkbox("Active", True)
    if st.button("Save Passage"):
        save("INSERT INTO lens(profile_id,passage,category,active) VALUES(?,?,?,?)",(pid,psg,cat,1 if active else 0))
        st.success("Saved.")
    rows = fetch("SELECT id, passage, category, active FROM lens WHERE profile_id=? ORDER BY id DESC", (pid,))
    if rows:
        st.subheader("Passages")
        for lid, p, c, a in rows:
            st.markdown(f"**[{c}]** {'üü¢' if a else '‚ö™'} ‚Äî {p}")
    st.subheader("Active Blend")
    cats = st.multiselect("Blend categories", ["recursion","emergence","neutral"], default=st.session_state.active_lens_cats)
    st.session_state.active_lens_cats = cats
    line = blended_lens_line(pid, cats)
    if line:
        st.markdown(f"<div class='narr'>{line}</div>", unsafe_allow_html=True)

def diagnostics_tab():
    st.header("‚öñÔ∏è Diagnostics")
    pid = current_profile()
    if not pid: st.info("Select a profile."); return
    since = (datetime.now().date() - timedelta(days=30)).isoformat()
    rows = fetch("SELECT category, value FROM loops WHERE profile_id=? AND date>=?", (pid, since))
    if not rows:
        st.info("No loops yet."); return
    forces, drags, neutral = {}, {}, {}
    force_kw = ["write","exercise","save","sleep","study","meditate","walk","water","focus"]
    drag_kw  = ["scroll","late","junk","skip","procrastinate","smoke","drink","binge"]
    for cat, val in rows:
        c = cat.lower()
        if any(k in c for k in force_kw): forces[cat] = forces.get(cat,0)+val
        elif any(k in c for k in drag_kw): drags[cat] = drags.get(cat,0)+val
        else: neutral[cat] = neutral.get(cat,0)+val
    if forces:
        st.plotly_chart(px.bar(x=list(forces.keys()), y=list(forces.values()), title="Forces (+)"), use_container_width=True)
    if drags:
        st.plotly_chart(px.bar(x=list(drags.keys()), y=list(drags.values()), title="Drags (‚Äì)"), use_container_width=True)
    tf, td = sum(forces.values()), sum(drags.values())
    if tf+td>0:
        ratio = tf/(tf+td)
        st.metric("Forces/Drags Balance", f"{ratio:.2f}")
        narr = ai_narration(pid, f"Forces={tf}, Drags={td}, Ratio={ratio:.2f}. Offer one sentence of coaching.")
        if not narr: narr = blended_lens_line(pid, ["emergence","neutral"])
        if narr: st.markdown(f"<div class='narr'>{narr}</div>", unsafe_allow_html=True)

# --------------
# Tab Routing
# --------------
tabs = st.tabs(["üìñ Guide", "üë§ Profiles", "üå† Future Self", "üéØ Goals", "üîÅ Loops",
                "üìà Forecast", "üõ† Interventions", "üìö Lens", "‚öñÔ∏è Diagnostics"])
with tabs[0]: guide_tab()
with tabs[1]: profiles_tab()
with tabs[2]: future_tab()
with tabs[3]: goals_tab()
with tabs[4]: loops_tab()
with tabs[5]: forecast_tab()
with tabs[6]: interventions_tab()
with tabs[7]: lens_tab()
with tabs[8]: diagnostics_tab()
with tabs[9]: show_settings()

# Base sanity ping
st.write("‚úÖ App loaded ‚Äî base render OK.")
